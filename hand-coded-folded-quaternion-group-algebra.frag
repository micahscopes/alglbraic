#version 130
#define providesInside
#define providesInit

#info Free module generated by {0, 1, 2, 3, 4} over Symbolic Ring
#include "Brute-Raytracer.frag"
#group Algebraic
    
const int N = 5;
uniform float JuliaVect1; slider[-2,0,2]
uniform float JuliaVect2; slider[-2,0,2]
uniform float JuliaVect3; slider[-2,0,2]
uniform float JuliaVect4; slider[-2,0,2]
uniform float JuliaVect5; slider[-2,0,2]

uniform float Position1; slider[-2,0,2]
uniform float Position2; slider[-2,0,2]
uniform float Position3; slider[-2,0,2]
uniform float Position4; slider[-2,0,2]
uniform float Position5; slider[-2,0,2]

uniform int FrameX; slider[1,1,5]
uniform int FrameY; slider[1,2,5]
uniform int FrameZ; slider[1,3,5]

// mutation indices (Lehmer or Lexicographic)
uniform int mutationA; slider[0,0,120]
uniform int mutationB; slider[0,0,120]
uniform int mutationC; slider[0,0,120]
uniform int mutationD; slider[0,0,120]



// extra parameters to play with (useful as weights)
uniform float A; slider[-2,1,2]
uniform float B; slider[-2,1,2]
uniform float C; slider[-2,1,2]
uniform float D; slider[-2,1,2]

// powers for multiplication, if need be
uniform int pow1; slider[0,1,24]
uniform int pow2; slider[0,1,24]
uniform int pow3; slider[0,1,24]
uniform int pow4; slider[0,1,24]

// ordinary fractal stuff
uniform int Iterations; slider[0,16,264]
uniform float Bailout; slider[0,5,30]
uniform bool Julia; checkbox[false]

// instead of adding the Julia point or z(0), use z(i-1) (the last point)
uniform bool usePrevious; checkbox[false]

    

float[N] product(float u[N], float v[N]) {
    return float[N](u[0]*v[0] + 2*u[1]*v[1] + 2*u[2]*v[2] + u[3]*v[3] + 2*u[4]*v[4], u[0]*v[1] + u[1]*v[0] + u[1]*v[3] + 2*u[2]*v[4] + u[3]*v[1] + 2*u[4]*v[2], u[0]*v[2] + 2*u[1]*v[4] + u[2]*v[0] + u[2]*v[3] + u[3]*v[2] + 2*u[4]*v[1], u[0]*v[3] + 2*u[1]*v[1] + 2*u[2]*v[2] + u[3]*v[0] + 2*u[4]*v[4], u[0]*v[4] + 2*u[1]*v[2] + 2*u[2]*v[1] + u[3]*v[4] + u[4]*v[0] + u[4]*v[3]);
}


float norm(float u[N]) {
    return pow(pow(u[0], 2.0) + pow(u[1], 2.0) + pow(u[2], 2.0) + pow(u[3], 2.0) + pow(u[4], 2.0), 0.5);
}


float[N] antipode(float u[N]) {
    return float[N](u[0], u[1], u[2], u[3], u[4]);
}

float[N] zero() {
  float zero[N];
  for(int i=0; i<N; ++i){zero[i] = 0;}
  return zero;
}

float[N] mul(float u[N], float v[N]) {
  return product(u,v);
}

float[N] mul(float a, float b[N]){
  float result[N];
  for (int i = 0; i < N; ++i){
    result[i] = a*b[i];
  }
  return result;
}

float[N] mul(float b[N], float a) {
  return mul(a,b);
}

float[N] mul(int a, float b[N]) {
  return mul(float(a),b);
}

float[N] mul(float b[N], int a) {
  return mul(float(a),b);
}

float[N] mul3(float a[N], float b[N], float c[N]) {
  return mul(mul(a,b),c);
}

float[N] pow(float a[N],int n) {
  // multiple a by itself n times: a -> a**n
	float r[N] = a;
	for (int i=0;i<n-1;i++){
	   r = mul(r,a);
    }
    return r;
}

float[N] add(float a[N], float b[N]) {
  float c[N];
  for (int i = 0; i < N; ++i){
    c[i] = a[i]+b[i];
  }
  return c;
}

float[N] sub(float a[N], float b[N]) {
  float c[N];
  for (int i = 0; i < N; ++i){
    c[i] = a[i]-b[i];
  }
  return c;
}


float[N] loadParamsJuliaVect(out float u[N]){
    u[0] = JuliaVect1; u[1] = JuliaVect2; u[2] = JuliaVect3; u[3] = JuliaVect4; u[4] = JuliaVect5; 
    return u;
}


float[N] loadParamsPosition(out float u[N]){
    u[0] = Position1; u[1] = Position2; u[2] = Position3; u[3] = Position4; u[4] = Position5; 
    return u;
}


float[N] frame(float v[N], vec3 p){
    // "Frame" a "window" through which to view vector v, via a "subvector" p.

    // Points p form a linear subspace of the N dimensional Euclidean space,
    // but not necessarily of the vector space we are looking at.  They are
    // really just "slices" of larger vectors.

    if(FrameX == FrameY || FrameX == FrameZ || FrameY == FrameZ) {
        return v; //error, please set frame indices to be different
    }
    for(int i = 0; i<N; i++) {
       if (i == FrameX-1) { v[i] = p[0]; }
        if (i == FrameY-1) { v[i] = p[1]; }
        if (i == FrameZ-1) { v[i] = p[2]; }
    }
return