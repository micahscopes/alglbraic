#define highp
#define mediump
#define lowp
#version 130
#define providesInside
#define providesInit

// #info Free module generated by {(1,3)(2,4)(5,6), (1,4,3,2), (1,4,3,2)(5,6)} over Symbolic Ring
// #donotrun

// #donotrun

// #buffer RGBA32F

// #info Simple 3D Setup
// #camera 3D

//// #vertex
//
//// #group Camera
//// Field-of-view
//uniform float FOV;
//uniform vec3 Eye;
//uniform vec3 Target;
//uniform vec3 Up;
//
//
////varying vec3 from;
//uniform vec2 pixelSize;
//varying vec2 coord;
//varying vec2 viewCoord;
//varying vec2 viewCoord2;
////varying vec3 dir;
//varying vec3 Dir;
//varying vec3 UpOrtho;
//varying vec3 Right;
//uniform int subframe;
//varying vec2 PixelScale;
//
//#ifdef providesInit
//void init(); // forward declare
//#else
//void init() {}
//#endif
//
//vec2 rand(vec2 co){
//	// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html
//	return
//	vec2(fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453),
//		fract(cos(dot(co.xy ,vec2(4.898,7.23))) * 23421.631));
//}
//
//
//
//void main(void)
//{
//	gl_Position =  gl_Vertex;
//	coord = (gl_ProjectionMatrix*gl_Vertex).xy;
//	coord.x*= pixelSize.y/pixelSize.x;
//
//	// we will only use gl_ProjectionMatrix to scale and translate, so the following should be OK.
//	PixelScale =vec2(pixelSize.x*gl_ProjectionMatrix[0][0], pixelSize.y*gl_ProjectionMatrix[1][1]);
//	viewCoord = gl_Vertex.xy;
//	viewCoord2= (gl_ProjectionMatrix*gl_Vertex).xy;
//
//	//from = Eye;
//	Dir = normalize(Target-Eye);
//	UpOrtho = normalize( Up-dot(Dir,Up)*Dir );
//	Right = normalize( cross(Dir,UpOrtho));
//	coord*=FOV;
//	init();
//}
// #endvertex

// #group Camera
uniform bool EquiRectangular;


// #group Raytracer

#define PI  3.14159265358979323846264

// Camera position and target.
//varying vec3 from;
//varying vec3 dir;
//varying vec3 dirDx;
//varying vec3 dirDy;
varying vec2 coord;
//varying float zoom;

uniform int subframe;
uniform sampler2D backbuffer;
varying vec2 viewCoord;
varying vec2 viewCoord2;
varying vec3 Dir;
varying vec3 UpOrtho;
varying vec3 Right;



#ifdef providesInit
void init(); // forward declare
#else
void init() {}
#endif
//out vec4 gl_FragColor;
// #group Post
uniform float Gamma;
// 1: Linear, 2: Expontial, 3: Filmic, 4: Reinhart
uniform int ToneMapping;
uniform float Exposure;
uniform float Brightness;
uniform float Contrast;
uniform float Saturation;

varying vec2 PixelScale;
uniform float FOV;

// implement this;
vec4 color(vec3 cameraPos, vec3 direction,float prev);

// Given a camera pointing in 'dir' with an orthogonal 'up' and 'right' vector
// and a point, coord, in screen coordinates from (-1,-1) to (1,1),
// a ray tracer direction is returned
vec3 equiRectangularDirection(vec2 coord, vec3 dir, vec3 up, vec3 right)  {
	vec2 r = vec2(coord.x,(1.0-coord.y)*0.5)*PI;
	return cos(r.x)*sin(r.y)*dir+
	sin(r.x)*sin(r.y)*right+
	cos(r.y)*up;
}
uniform vec3 Eye;


void fragmentariumMain() {
	init();
	vec3 hitNormal = vec3(0.0);
	vec3 hit;

	vec3 rayDir =  (Dir+ coord.x*Right+coord.y*UpOrtho);
	rayDir = normalize(rayDir);

	if (EquiRectangular) {
		rayDir = equiRectangularDirection(viewCoord2, Dir, UpOrtho, Right);
	}

	vec4 prev = texture2D(backbuffer,(viewCoord+vec2(1.0))/2.0);
	vec4 c =  color(Eye,rayDir, prev.w);
	gl_FragColor =c;
}

// #group default

// #group Camera


// #group Raytracer

uniform float NormalScale;
uniform float AOScale;
uniform float Glow;
uniform float AOStrength;

// Maximum number of  raymarching steps.
uniform int Samples;
uniform bool Stratify;
uniform bool DebugInside;
uniform bool CentralDifferences;
uniform bool SampleNeighbors;

uniform float Near;
uniform float Far;

uniform bool ShowDepth;
uniform bool DebugNormals;

// #group Light

// The specular intensity of the directional light
uniform float Specular;
// The specular exponent
uniform float SpecularExp;
// Color and strength of the directional light
uniform vec4 SpotLight;
// Direction to the spot light (spherical coordinates)
uniform vec2 SpotLightDir;
// Light coming from the camera position (diffuse lightning)
uniform vec4 CamLight;
// Controls the minimum ambient light, regardless of directionality
uniform float CamLightMin;

uniform float Fog;


vec4 orbitTrap = vec4(10000.0);

// #group Coloring

// This is the pure color of object (in white light)
uniform vec3 BaseColor;
// Determines the mix between pure light coloring and pure orbit trap coloring
uniform float OrbitStrength;

// Closest distance to YZ-plane during orbit
uniform vec4 X;

// Closest distance to XZ-plane during orbit
uniform vec4 Y;

// Closest distance to XY-plane during orbit
uniform vec4 Z;

// Closest distance to  origin during orbit
uniform vec4 R;

// Background color
uniform vec3 BackgroundColor;
// Vignette background
uniform float GradientBackground;

float DE(vec3 pos) ; // Must be implemented in other file

uniform bool CycleColors;
uniform float Cycles;

// #group Floor

vec3 colorBase = vec3(0.0,0.0,0.0);

vec3 getColor() {
	orbitTrap.w = sqrt(orbitTrap.w);

	vec3 orbitColor;
	orbitColor = X.xyz*X.w*orbitTrap.x +
	Y.xyz*Y.w*orbitTrap.y +
	Z.xyz*Z.w*orbitTrap.z +
	R.xyz*R.w*orbitTrap.w;

	vec3 color = mix(BaseColor, 3.0*orbitColor,  OrbitStrength);
	return color;
}

float rand(vec2 co){
	// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html
	return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

#ifdef  providesColor
vec3 color(vec3 point);
#endif

#ifdef providesInside
bool inside(vec3 p);
#else
bool inside(vec3 p) {
	return (DE(p) < 0.0);
}
#endif

uniform vec2 pixelSize;
vec4 color(vec3 from, vec3 dir, float closest) {
	vec3 direction = normalize(dir);
	float dist = 0.0;
	if (closest<=0. || closest>1.) { closest = 1.0; }

	bool startsInside = inside(from + Near * direction);


	// Check neighbors
	if (SampleNeighbors && subframe>1) {
		vec2 position = (viewCoord*1.0+vec2(1.0))/2.0;

		for (int dx = -1; dx<=1; dx++) {
			for (int dy = -1; dy<=1; dy++) {
				float dist = texture2D( backbuffer,  position + pixelSize*vec2( dx, dy ) ).w;
				if (dist < closest) {
					vec3 point = from + (Near+dist*(Far-Near)) * direction;
					if (inside(point) != startsInside) {
						closest = dist;
					}
				}
			}
		}
	}

	if (Stratify) {
		float stepSize =  closest / float(Samples);

		float dither= rand(viewCoord*float(subframe));
		dist += dither*stepSize;
		int steps;
		for (steps=0; steps<Samples; steps++) {
			vec3 point = from + (Near+dist*(Far-Near)) * direction;
			if (inside(point) != startsInside) break;
			dist += stepSize;
		}
		if (steps!=Samples) closest = dist;
	} else {

		for (int i=0; i<Samples; i++) {
			dist = closest*rand(viewCoord*float(subframe*i));
			vec3 point = from + (Near+dist*(Far-Near)) * direction;
			if (inside(point) != startsInside) {
				closest = dist;
			}
		}
	}

	if (closest >= 1.0) {
		vec3 backColor = BackgroundColor;
		if (GradientBackground>0.0) {
			float t = length(coord);
			backColor = mix(backColor, vec3(0.0,0.0,0.0), t*GradientBackground);
		}
		return vec4(backColor,1.0);
	}

#ifdef  providesColor
	vec3 hitColor = mix(BaseColor,  color( from + (Near+closest*(Far-Near)) * direction),  OrbitStrength);
#else
	vec3 hitColor = getColor();
#endif
	if (DebugInside) {
		if (startsInside) {
			hitColor = vec3(1.0,0.0,0.0);

		} else {
			hitColor = vec3(0.0,1.0,0.0);
		}
	}

	return vec4(hitColor,closest);
}

// #group default
// #group Algebraic

const int N = 3;
uniform float JuliaVect1;
uniform float JuliaVect2;
uniform float JuliaVect3;

uniform float Position1;
uniform float Position2;
uniform float Position3;

uniform int FrameX;
uniform int FrameY;
uniform int FrameZ;

// mutation indices (Lehmer or Lexicographic)
uniform int mutationA;
uniform int mutationB;
uniform int mutationC;
uniform int mutationD;



// extra parameters to play with (useful as weights)
uniform float A;
uniform float B;
uniform float C;
uniform float D;

// powers for multiplication, if need be
uniform int pow1;
uniform int pow2;
uniform int pow3;
uniform int pow4;

// ordinary fractal stuff
uniform int Iterations;
uniform float Bailout;
uniform bool Julia;

// instead of adding the Julia point or z(0), use z(i-1) (the last point)
uniform bool usePrevious;



float[N] product(float u[N], float v[N]) {
    return float[N](-u[0]*v[0] + u[1]*v[1] + u[1]*v[2] + u[2]*v[1] + u[2]*v[2], -u[0]*v[2] - u[2]*v[0], -u[0]*v[1] - u[1]*v[0]);
}


float norm(float u[N]) {
    return pow(pow(u[0], 2.0) + pow(u[1], 2.0) + pow(u[2], 2.0), 0.5);
}


float[N] antipode(float u[N]) {
    return float[N](u[0], -u[1], -u[2]);
}

float[N] zero() {
  float zero[N];
  for(int i=0; i<N; ++i){zero[i] = 0;}
  return zero;
}

float[N] mul(float u[N], float v[N]) {
  return product(u,v);
}

float[N] mul(float a, float b[N]){
  float result[N];
  for (int i = 0; i < N; ++i){
    result[i] = a*b[i];
  }
  return result;
}

float[N] mul(float b[N], float a) {
  return mul(a,b);
}

float[N] mul(int a, float b[N]) {
  return mul(float(a),b);
}

float[N] mul(float b[N], int a) {
  return mul(float(a),b);
}

float[N] mul3(float a[N], float b[N], float c[N]) {
  return mul(mul(a,b),c);
}

float[N] pow(float a[N],int n) {
  // multiple a by itself n times: a -> a**n
	float r[N] = a;
	for (int i=0;i<n-1;i++){
	   r = mul(r,a);
    }
    return r;
}

float[N] add(float a[N], float b[N]) {
  float c[N];
  for (int i = 0; i < N; ++i){
    c[i] = a[i]+b[i];
  }
  return c;
}

float[N] sub(float a[N], float b[N]) {
  float c[N];
  for (int i = 0; i < N; ++i){
    c[i] = a[i]-b[i];
  }
  return c;
}


float[N] loadParamsJuliaVect(out float u[N]){
    u[0] = JuliaVect1; u[1] = JuliaVect2; u[2] = JuliaVect3;
    return u;
}


float[N] loadParamsPosition(out float u[N]){
    u[0] = Position1; u[1] = Position2; u[2] = Position3;
    return u;
}


float[N] frame(float v[N], vec3 p){
    // "Frame" a "window" through which to view vector v, via a "subvector" p.

    // Points p form a linear subspace of the N dimensional Euclidean space,
    // but not necessarily of the vector space we are looking at.  They are
    // really just "slices" of larger vectors.

    if(FrameX == FrameY || FrameX == FrameZ || FrameY == FrameZ) {
        return v; //error, please set frame indices to be different
    }
    for(int i = 0; i<N; i++) {
       if (i == FrameX-1) { v[i] = p[0]; }
        if (i == FrameY-1) { v[i] = p[1]; }
        if (i == FrameZ-1) { v[i] = p[2]; }
    }
return v;
}

int[N] permutationLexicographic(int i)
{
   int j, k = 0;
   int fact[N];
   int perm[N];

   // compute factorial numbers
   fact[k] = 1;
   while (++k < N)
      fact[k] = fact[k - 1] * k;

   // compute factorial code
   for (k = 0; k < N; ++k)
   {
      perm[k] = i / fact[N - 1 - k];
      i = i % fact[N - 1 - k];
   }

   // readjust values to obtain the permutation
   // start from the end and check if preceding values are lower
   for (k = N - 1; k > 0; --k)
      for (j = k - 1; j >= 0; --j)
         if (perm[j] <= perm[k])
            perm[k]++;

    return perm;
}

int[N] permutationLehmer(int n) {
    int result[N];
    int working[N];
    for (int i = 0; i < N; i++) {
        result[i] = i;
        working[i] = i;
    }
    int item;
    bool found = false;
    for (int i = 0; i < N; i++) {
        item = int(n % (N-i));
        n = int(floor(n / (N-i)));
        result[i] = working[item];
        for (int j = 0; j<N-i-1; j++) {
            if(working[j] == result[i]) {found = true;}
            if(found){working[j] = working[j+1];}
        }
    }
    return result;
}

int[N] permutation(int n){
  // choose which variation you want to use
  return permutationLehmer(n);
}

float[N] mutate(float A[N],int P[N],bool inverse) {
    float permutated[N] = zero();
    for(int i = 0; i < N; i++) {
        if(!inverse) {
            permutated[i] = A[P[i]];
        } else {
            permutated[P[i]] = A[i];
        }
    }
    return permutated;
}

float[N] mutate(float A[N],int P[N]) {
  return mutate(A,P,false);
}

// the mutations
int MA[N];
int MB[N];
int MC[N];
int MD[N];

void initMutations() {
	MA = permutation(mutationA);
	MB = permutation(mutationB);
	MC = permutation(mutationC);
	MD = permutation(mutationD);
}


float O[N];
float JuliaVect[N];

void init(){
    loadParamsPosition(O);
    loadParamsJuliaVect(JuliaVect);
    initMutations();
}

void iter(inout float z[N]) {

float MzA[N] = mutate(z,MA);
float MzB[N] = mutate(z,MB);
z = mul(
    pow(MzA,pow1),
    pow(MzB,pow2)
);

}

bool inside(vec3 pt) {
    float z[N] = frame(O,pt);
    float z0[N] = z;
  	float r;
  	int i=0;
  	r=abs(norm(z));

    while(r<Bailout && (i<Iterations)) {
      float zprev[N];
      if (usePrevious) { zprev = z; } else { zprev = z0; }
  		iter(z);
  		z = add(z,(Julia ? JuliaVect : zprev));
  		r=norm(z);
  		i++;
  	}
	return (r<Bailout);
}


// #group default

void main() { fragmentariumMain(); }
